% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}
%
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage[english]{babel}
\usepackage{url}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}
\urlstyle{rm}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}
\begin{document}
%
\title{The Knapsack Problem}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Andrei RUSĂNESCU,
 Gabriel-Ioan PAVEL,
Amir FALLAH-MIRZAEI}
%
\institute{Universitatea de Știință și Tehnologie POLITEHNICA București}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
The present paper analyses several algorithms that solve the Knapsack problem,
taking into account both the speed and the memory used by the program. It
presents three solutions, two of which always generate the correct answer, and
one that obtains a result close to the right one.

\end{abstract}
%
%
%
\section{Introduction}
The Knapsack problem derives its name from the situation faced by someone who wants
to fill their limited-capacity knapsack with the most valuable items that can fit.
You can choose whether to put it in the bag or not put it at all, hence the name
"0/1 Knapsack Problem". The problem has been studied for more than a century, with
writings dating as far back as 1897. 

\subsubsection{Aplicații practice} Printre domeniile în care apare Problema
Rucsacului se numără: găsirea unei metode cât mai puțin risipitoare de a tăia
materii prime, selecția investițiilor și a portofoliilor, selectarea activelor
pentru securitizare garantată cu active etc.

\section{Demonstrație NP-Hard}
%TODO: Amir

\section{Prezentarea algoritmilor}
%TODO: Gebi
\subsection{Programare dinamică}
Rezolvarea problemei prin metoda programării dinamice reprezintă construirea
unei matrici ce stochează profitul maxim pentru subproblemele definite de
primele \textbf{i} obiecte și o capacitate \textbf{w} a rucsacului.

\begin{lstlisting}
int knapsack(const int &maxWeight, std::vector<int> &weights, std::vector<int> &values) {
	// numar de obiecte
	int n = weights.size();

	/* matrice - dp[i][w] == profitul maxim ce poate fi obtinut folosind primele i obiecte cu limita de masa w */
	std::vector<std::vector<int>> dp(n + 1, std::vector<int>(maxWeight + 1));

	/* daca nu intra niciun obiect in calcul sau masa maxima este 0, atunci profitul este 0 */
	for (int i = 0; i <= n; ++i)
		dp[i][0] = 0;
	for (int j = 0; j <= maxWeight; ++j)
		dp[0][j] = 0;
\end{lstlisting}

Următoarea buclă parcurge fiecare element al matricei, unde fiecare linie
reprezintă un obiect, iar fiecare coloană reprezintă o masă maximă, astfel
încât dp[i][w] reprezintă profitul maxim obținut folosind primele \textbf{i}
obiecte cu limita de masă \textbf{w}.

Logica este următoarea: dacă obiectul curent
se încadrează în masa maximă curentă, atunci alegem să îl includem sau să îl
excludem din calcul, în funcție de profitul maxim pe care îl putem obține. Mai exact,
dacă alegem să îl includem, adunăm valoarea sa cu profitul maxim care se poate obține
având în vedere masa folosibilă rămasă, iar, dacă alegem să îl excludem, păstrăm profitul
maxim ce poate fi obținut precedent.

Contrar, dacă masa obiectului curent întrece limita curentă, acesta va fi exclus din calcul,
păstrându-se profitul precedent.

\begin{lstlisting}
	for (int i = 1; i <= n; ++i) {
		for (int w = 1; w <= maxWeight; ++w) {
			if (weights[i - 1] <= w)
				dp[i][w] = std::max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);
			else
				dp[i][w] = dp[i - 1][w];
		}
	}

	return dp[n][maxWeight];
}
\end{lstlisting}

Rezultatul căutat se află pe ultima poziție din tabel.

\subsubsection{Analiza complexității}

\paragraph{Complexitate temporală} Primele două bucle \textit{for} execută \textbf{n},
respectiv \textbf{maxWeight} operații de timp constant. Pentru următoarele două bucle,
cea exterioară iterează prin fiecare obiect, iar cea interioară prin fiecare masă maximă
posibilă. Operațiile executate în interiorul buclei interne sunt de timp constant. Astfel,
complexitatea temporală a algoritmului este de \textbf{O(n * maxWeight)}.

\paragraph{Complexitate spațială} Întrucât este folosită o matrice de dimensiuni \textbf{(n+1) * (maxWeight+1)},
complexitatea spațială este \textbf{O(n * maxWeight)}.

\subsubsection{Avantaje și dezavantaje}

\paragraph{Avantaje} Avantajele principale sunt reprezentate de viteza de execuție, întrucât se poate
obține un rezultat în timp rezonabil și evitarea problemelor ce ar fi putut apărea în situația
folosirii recursivității, precum supraîncărcarea stivei.

\paragraph{Dezavantaje} Dezavantajele principale sunt reprezentate de folosirea unei zone mari de
memorie și faptul că dimensiunea matricii nu poate fi ajustată dinamic fără recalcularea valorilor.


\subsection{Memoizare}
Această metodă de programare dinamică se folosește de memoizare și recursivitate pentru
a evita recalcularea inutilă a unor subprobleme.

Execuția începe în funcția auxiliară, \textbf{knapSackMemoHelper}, care inițializează variabilele
și începe execuția algoritmului propriu-zis.

\begin{lstlisting}
inline int knapSackMemoHelper(int W, std::vector<int> &weights, std::vector<int> &vals) {
	int n = weights.size();
	std::vector<std::vector<int>> memo(n, std::vector<int>(W + 1, -1));

	/* W - capacitatea maxima curenta, index - indicele obiectului curent */
	return knapSackMemo(W, weights, vals, n - 1, memo);
}
\end{lstlisting}

Funcția principală începe prin a verifica cazul opririi recursivității - s-au
luat în calcul toate obiectele - ca apoi să verifice dacă profitul pentru obiectul
curent și capacitatea W a fost deja calculat. În caz afirmativ, rezultatul este întors
direct, fără a mai fi făcute calcule redundante.

Algoritmul verifică dacă masa obiectului curent este mai mare decât capacitatea rămasă
în rucsac. Dacă da, obiectul trebuie exclus. Altfel, se calculează profitul maxim care
se poate obține din includerea sau excluderea obiectului curent, similar cu metoda anterioară,
și rezultatul este păstrat în matricea de memoizare.

\begin{lstlisting}
int knapSackMemo(int W, std::vector<int> &weights, std::vector<int> &vals, int index, std::vector<std::vector<int>> &memo) {
	if (index < 0)
		return 0;
	
	if (memo[index][W] != -1)
		return memo[index][W];

	if (weights[index] > W)
		return memo[index][W] = knapSackMemo(W, weights, vals, index - 1, memo);

	return memo[index][W] = std::max(
		knapSackMemo(W, weights, vals, index - 1, memo),
		vals[index] + knapSackMemo(W - weights[index], weights, vals, index - 1, memo));
}
\end{lstlisting}

\subsubsection{Analiza complexității}

\paragraph{Complexitate temporală} Fiecare subproblemă este unică, este rezolvată o singură
dată și este definită de indicele unui obiect și capacitatea rămasă în rucsac într-un moment.
Astfel, ajungem la un număr de \textbf{n * maxWeight} de subprobleme, iar complexitatea
temporală ajunge să fie \textbf{O(n * maxWeight)}, întrucât operațiile ce trebuie executate
pentru a rezolva subproblemele sunt de timp constrant.

\paragraph{Complexitate spațială} Fiind folosită o matrice de dimensiune \textbf{n * (maxWeight + 1)},
iar stiva având o dimensiune maximă de \textbf{n}, complexitatea spațială este de aproximativ
\textbf{O(n * maxWeight)}.

\subsubsection{Avantaje și dezavantaje}

\paragraph{Avantaje} Principalele avantaje ale acestei abordări sunt reprezentate de viteza
de execuție și calcului soluțiilor strict necesare, comparativ cu metoda programării dinamice,
unde toate elementele matricii sunt calculate.

\paragraph{Dezavantaje} Principalele dezavantaje sunt reprezentate de utilizarea unei zone mari de memorie
și riscul unui stack overflow, atunci când \textbf{n} este foarte mare.

\subsection{Backtracking}

Această abordare verifică fiecare combinație de obiecte posibilă în mod recursiv. Funcția care începe
algoritmul este una auxiliară, având ca scop inițializarea variabilelor și apelarea funcției principale.
Aici, \textbf{maxxW} reprezintă masa maximă suportată de rucsac, \textbf{maxx} profitul maxim într-un anumit
moment, \textbf{size} numărul de obiecte, \textbf{ws} și \textbf{vals} copii ale vectorilor de mase, respectiv
valori ale obiectelor. Funcția se finalizează prin returnarea rezultatului final.

\begin{lstlisting}
inline int knapsack_back(const int &maxWeight, std::vector<int> &weights, std::vector<int> &values) {
	maxx = 0;
	maxxW = maxWeight;
	ws = weights;
	vals = values;
	size = weights.size();
	back(0, 0, 0);
	return maxx;
}
\end{lstlisting}

Fiecare apel al funcției principale verifică dacă obiectul curent se încadrează în
masa maximă curentă a rucsac. Dacă da, actualizează profitul maxim curent, altfel încheie
execuția. Dacă s-au luat toate obiectele în considerare, execuția este oprită.

În continuare, funcția iterează prin toate obiectele începând cu un \textbf{index}. Pentru
fiecare obiect, adaugă masa și valoarea sa la profitul curent și masa folosită curentă și
merge mai departe în recursivitate. După finalizarea recursivității, elimină valoarea și
masa sa din variabilele corespunzătoare.

\begin{lstlisting}
void back(int index, int currWeight, int currProfit) {
	if (currWeight <= maxxW)
		maxx = std::max(maxx, currProfit);
	else return;

	if (index == size) {
		return;
	}

	for (int i = index; i < size; ++i) {
		currProfit += vals[i];
		currWeight += ws[i];
		back(i + 1, currWeight, currProfit);
		currProfit -= vals[i];
		currWeight -= ws[i];
	}
}
\end{lstlisting}

\subsubsection{Analiza complexității}

\paragraph{Complexitate temporală} Toate operațiile de bază executate la fiecare
iterație în recursivitate sunt de timp liniar, iar, din moment ce algoritmul explorează
toate combinațiile posibile de obiecte, ajungem la un număr de $2^n$ iterații. Astfel,
complexitatea temporală a algoritmului este de \textbf{O($2^n$)}.

\paragraph{Complexitate spațială} Având \textbf{n} elemente de verificat, dimensiunea stivei
de execuție ajunge la maxim \textbf{n}, deci complexitatea spațială este de \textbf{O(n)}.

\subsubsection{Avantaje și dezavantaje}

\paragraph{Avantaje} Avantaje acestei abordări sunt reprezentate de simplitatea în implementarea
algoritmului și dimensiunea relativ redusă a memoriei utilizate.

\paragraph{Dezavantaje} Întrucât această metodă este una de bruteforce, durata de execuție este
foarte ridicată și se realizează foarte multe calcule redundante, ineficiența sa devine un
un dezavantaj masiv.

\subsection{Recursivitate}

Abordarea recursivă parcurge toate combinațiile posibile de obiecte fără a păstra valori intermediare.

Algoritmul începe prin a trata cazul de bază, unde fie nu mai este spațiu disponibil
în rucsac, fie s-au luat toate obiectele în considerare, caz în care execuția se încheie.
În continuare, verifică dacă masa obiectului curent se încadrează în masa maximă rămasă.
În cazul afirmativ, obiectul nu poate fi luat în calcul, iar recursivitea continuă fără
a-l include. În caz contrat, se decide dacă valoarea obiectului curent poate contribui la creșterea
profitului maxim și se include sau exclude în funcție de concluzie, similar cu algortimii precedenți.

\begin{lstlisting}
int knapSack(int W, std::vector<int> &weights, std::vector<int> &vals, int n) {
	if (n == 0 || W == 0)
		return 0;

	if (weights[n - 1] > W)
		return knapSack(W, weights, vals, n - 1);

	return std::max(knapSack(W, weights, vals, n - 1),
					vals[n - 1] + knapSack(W - weights[n - 1], weights, vals, n - 1));
}
\end{lstlisting}

\subsubsection{Analiza complexității}

\paragraph{Complexitate temporală} Algoritmul explorează toate combinațiile posibile de obiecte,
ajungându-se astfel la o complexitate temporală de \textbf{O($2^n$)}.

\paragraph{Complexitate spațială} Cum numărul de obiecte este \textbf{n}, adâncimea maximă
a stivei poate fi de \textbf{n}, deci complexitatea spațială este de \textbf{O(n)}.

\subsubsection{Avantaje și dezavantaje}

\paragraph{Avantaje} Avantajele acestei abordări sunt aproape inexistente, singurele fiind
simplitatea implementării și dimensiunea relativ redusă a stivei de execuție.

\paragraph{Dezavantaje} Timpul de execuție este cel mai dezavantajos aspect al acestui algoritm,
fiind foarte lent, în special pe intrări de dimensiune ridicată.

\section{Evaluare}
%TODO: Andrei + Gebi

\section{Concluzii}
%TODO: Gebi

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
\begin{thebibliography}{8}
\bibitem{ref_article1}
Pavel, G.-I.: \emph{Knapsack problem}, \url{https://en.wikipedia.org/wiki/Knapsack_problem} [Accesat la 04/01/2025].

\bibitem{ref_url1}
LNCS Homepage, \url{http://www.springer.com/lncs}, Accesat la [04/01/2025]


\end{thebibliography}
\end{document}